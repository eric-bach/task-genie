<!doctype html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Task Genie</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 10px;
        font-family: 'Segoe UI VSS (Regular)', '-apple-system', BlinkMacSystemFont, 'Segoe UI', sans-serif;
        font-size: 13px;
        color: #333;
        background-color: transparent;
      }

      body.dark-mode {
        color: #f1f1f1;
      }

      .container {
        display: flex;
        flex-direction: row;
        gap: 20px;
        width: 100%;
        max-width: none;
      }

      .left-column {
        flex: 0 0 auto;
        width: 800px; /* Or 50% if preferred, but user said "existing container width ... half of form" */
        max-width: 50%;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .right-column {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      /* Buttons */
      button {
        padding: 6px 16px;
        border-radius: 2px;
        border: 1px solid transparent;
        cursor: pointer;
        font-family: inherit;
        font-size: 13px;
        font-weight: 600;
        transition: background-color 0.2s;
      }

      .btn-primary {
        background-color: #0078d4;
        color: white;
      }

      .btn-primary:hover {
        background-color: #106ebe;
      }

      .btn-primary:disabled {
        background-color: #c8c8c8;
        cursor: not-allowed;
        color: #666;
      }

      .btn-secondary {
        background-color: white;
        border-color: #8a8886;
      }

      .dark-mode .btn-secondary {
        background-color: transparent;
        color: #f1f1f1;
        border-color: #f1f1f1;
      }

      .btn-secondary:hover {
        background-color: #f3f2f1;
      }

      .dark-mode .btn-secondary:hover {
        background-color: #333;
      }

      /* Results Area */
      .results-area {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .work-item-card {
        border: 1px solid #e1dfdd;
        border-left: 4px solid #0078d4;
        border-radius: 2px;
        padding: 12px;
        background-color: #fff;
      }

      .dark-mode .work-item-card {
        background-color: #252526;
        border-color: #3e3e42;
        border-left-color: #0078d4;
      }

      .card-header {
        display: flex;
        align-items: center;
        margin-bottom: 6px;
        gap: 8px;
      }

      .work-item-type {
        font-weight: 600;
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 4px;
        background-color: #eff6fc;
        color: #0078d4;
        text-transform: uppercase;
      }

      .dark-mode .work-item-type {
        background-color: #3a3d41;
        color: #61dafb;
      }

      .work-item-title {
        font-weight: 600;
        font-size: 14px;
      }

      .work-item-description {
        color: #666;
        font-size: 12px;
        line-height: 1.4;
      }

      .dark-mode .work-item-description {
        color: #ccc;
      }

      /* Status & Feedback */
      .status-message {
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 13px;
      }

      .status-info {
        background-color: #eff6fc;
        color: #005a9e;
      }
      .status-success {
        background-color: #dff6dd;
        color: #107c10;
      }
      .status-error {
        background-color: #fde7e9;
        color: #a80000;
      }

      .dark-mode .status-info {
        background-color: #2b3c4e;
        color: #92c5f9;
      }
      .dark-mode .status-success {
        background-color: #0f3d0f;
        color: #92f992;
      }
      .dark-mode .status-error {
        background-color: #4e2b2c;
        color: #f99292;
      }

      .spinner {
        border: 2px solid #c7e0f4;
        border-top: 2px solid #0078d4;
        border-radius: 50%;
        width: 14px;
        height: 14px;
        animation: spin 1s linear infinite;
        display: inline-block;
        margin-right: 6px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .hidden {
        display: none !important;
      }

      .empty-state {
        padding: 20px;
        text-align: center;
        color: #666;
        border: 1px dashed #ccc;
        border-radius: 4px;
      }
      .results-actions {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        margin-top: 12px;
      }
      .results-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        min-height: 32px;
      }

      .header-actions {
        display: flex;
        gap: 8px;
      }

      /* CRUD Actions */
      .card-actions {
        margin-left: auto;
        display: flex;
        gap: 4px;
      }

      .btn-icon {
        background: none;
        border: none;
        cursor: pointer;
        padding: 4px;
        color: #666;
        border-radius: 2px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .btn-icon:hover {
        background-color: #f3f2f1;
        color: #0078d4;
      }

      .dark-mode .btn-icon:hover {
        background-color: #3a3d41;
        color: #61dafb;
      }

      .btn-sm {
        padding: 4px 8px;
        font-size: 11px;
      }

      /* Edit Mode Inputs */
      .edit-input {
        width: 100%;
        padding: 6px;
        margin-bottom: 8px;
        border: 1px solid #8a8886;
        border-radius: 2px;
        font-family: inherit;
        font-size: inherit;
        box-sizing: border-box;
      }

      .dark-mode .edit-input {
        background-color: #333;
        color: #f1f1f1;
        border-color: #8a8886;
      }

      .edit-textarea {
        width: 100%;
        padding: 6px;
        min-height: 60px;
        border: 1px solid #8a8886;
        border-radius: 2px;
        font-family: inherit;
        font-size: inherit;
        resize: vertical;
        box-sizing: border-box;
      }

      .dark-mode .edit-textarea {
        background-color: #333;
        color: #f1f1f1;
        border-color: #8a8886;
      }

      .edit-controls {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        margin-top: 8px;
      }

      /* Chat Window */
      .chat-container {
        display: flex;
        flex-direction: column;
        border: 1px solid #e1dfdd;
        border-radius: 2px;
        background-color: #fff;
        height: 400px; /* Fixed height for now, or flex-grow */
      }

      .dark-mode .chat-container {
        background-color: #252526;
        border-color: #3e3e42;
      }

      .chat-header {
        padding: 8px 12px;
        border-bottom: 1px solid #e1dfdd;
        font-weight: 600;
        background-color: #f3f2f1;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .dark-mode .chat-header {
        background-color: #3a3d41;
        border-color: #3e3e42;
        color: #f1f1f1;
      }

      .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .message {
        max-width: 85%;
        padding: 8px 12px;
        border-radius: 12px;
        font-size: 13px;
        line-height: 1.4;
        word-wrap: break-word;
      }

      .message.user {
        align-self: flex-end;
        background-color: #0078d4;
        color: white;
        border-bottom-right-radius: 2px;
      }

      .message.assistant {
        align-self: flex-start;
        background-color: #f3f2f1;
        color: #333;
        border-bottom-left-radius: 2px;
      }

      .dark-mode .message.assistant {
        background-color: #3a3d41;
        color: #f1f1f1;
      }

      .chat-input-area {
        padding: 10px;
        border-top: 1px solid #e1dfdd;
        display: flex;
        gap: 8px;
        background-color: #fff;
      }

      .dark-mode .chat-input-area {
        background-color: #252526;
        border-color: #3e3e42;
      }

      .chat-input {
        flex: 1;
        padding: 6px 8px;
        border: 1px solid #8a8886;
        border-radius: 2px;
        resize: none;
        height: 32px;
        font-family: inherit;
        font-size: 13px;
        line-height: 20px;
      }

      .chat-input:focus {
        outline: 1px solid #0078d4;
        border-color: #0078d4;
      }

      .dark-mode .chat-input {
        background-color: #1e1e1e;
        color: #f1f1f1;
        border-color: #8a8886;
      }

      .typing-indicator {
        font-style: italic;
        color: #666;
        font-size: 11px;
        margin-left: 4px;
        margin-bottom: 4px;
        display: none;
      }
      .dark-mode .typing-indicator {
        color: #aaa;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Left Column: Content -->
      <div class="left-column">
        <!-- Waiting for Generation / Empty State -->
        <div id="emptyState" class="empty-state">
          <p>No work items found.</p>
          <p>Click "Generate" with "Preview" checked on the Details tab to generate work items.</p>
        </div>

        <!-- Loading State -->
        <div id="loadingState" class="empty-state hidden">
          <div class="spinner"></div>
          <p style="margin-top: 10px">Generating work items... this may take a minute.</p>
        </div>

        <!-- Results / Preview Area -->
        <div id="resultsArea" class="results-area hidden">
          <!-- Status Area -->
          <div id="statusContainer" class="hidden"></div>

          <div class="results-header">
            <h3 style="margin: 0">Generated Work Items</h3>
            <div class="header-actions">
              <button id="addItemBtn" class="btn-secondary" title="Add New Task">+ Add Task</button>
              <button id="createItemsBtn" class="btn-primary">Create Work Items</button>
              <button id="discardBtn" class="btn-secondary">Discard</button>
            </div>
          </div>
          <div id="itemsContainer">
            <!-- Items injected here -->
          </div>
        </div>
      </div>

      <!-- Right Column: Status -->
      <div class="right-column">
        <div class="results-area" style="gap: 12px; display: flex; flex-direction: column">
          <div class="results-header">
            <div style="display: flex; align-items: center; gap: 8px">
              <svg fill="currentColor" height="16" viewBox="0 0 16 16" width="16">
                <path d="M8 2a4 4 0 100 8 4 4 0 000-8zM8 0a6 6 0 110 12A6 6 0 018 0zm.5 11h-1v4h1v-4z" />
              </svg>
              <h3 style="margin: 0">Refine with AI</h3>
            </div>
            <button id="clearChatBtn" class="btn-icon" title="Clear Chat">
              <svg fill="currentColor" height="14" viewBox="0 0 16 16" width="14">
                <path d="M11 2H9c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1H2v2h9V2zm3 2H1v2h1v10h10V6h1V4zM3 14V6h8v8H3z" />
              </svg>
            </button>
          </div>
          <!-- LLM Chat Window -->
          <div id="chatContainer" class="chat-container">
            <div id="chatMessages" class="chat-messages">
              <div class="message assistant">
                Hello! I can help you refine these work items. Tell me what changes you'd like to make.
              </div>
            </div>
            <div id="typingIndicator" class="typing-indicator">AI is thinking...</div>
            <div class="chat-input-area">
              <textarea
                id="chatInput"
                class="chat-input"
                placeholder="Type a message... (e.g., 'Make the acceptance criteria more detailed')"
              ></textarea>
              <button
                id="sendChatBtn"
                class="btn-primary btn-icon"
                title="Send"
                style="width: 32px; height: 32px; padding: 0"
              >
                <svg fill="currentColor" height="16" viewBox="0 0 16 16" width="16">
                  <path
                    d="M15.854.146a.5.5 0 0 1 .11.54l-5.819 14.547a.75.75 0 0 1-1.329.124l-3.178-4.995L.643 7.184a.75.75 0 0 1 .124-1.33L15.314.037a.5.5 0 0 1 .54.11ZM6.636 10.07l2.761 4.338L14.13 2.576 6.636 10.07Zm6.787-8.201L1.591 6.602l4.339 2.76 7.494-7.493Z"
                  />
                </svg>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      window.requirejs.config({
        enforceDefine: true,
        paths: {
          SDK: './lib/SDK.min',
        },
      });

      window.requirejs(['SDK'], function (SDK) {
        // State
        let generatedItems = [];
        let sourceWorkItem = null;
        let currentConfig = null; // { apiUrl, apiKey }
        let lastRawData = '';
        let isPollingBackend = false;

        SDK.init().then(() => {
          SDK.register(SDK.getContributionId(), () => {
            return {};
          });
          SDK.ready().then(() => {
            initialize();
          });
        });

        // Custom error for session expiration
        class SessionExpiredError extends Error {
          constructor(message) {
            super(message);
            this.name = 'SessionExpiredError';
          }
        }

        // Helper to get token with retry for SDK errors (Shared logic)
        const getAppToken = async () => {
          try {
            let token = await SDK.getAppToken();

            // Check client-side expiry
            const decoded = parseJwt(token);
            const now = Date.now() / 1000;
            if (decoded && decoded.exp && decoded.exp < now) {
              console.warn('Token appears expired client-side. Requesting fresh token...');
              // In some SDK versions, getAppToken always returns a promise, hopefully a fresh one if the previous is invalid
              token = await SDK.getAppToken();
            }

            return token;
          } catch (e) {
            // Check if this is a TF400813 authorization error (session expired)
            const errorMessage = e.message || '';
            if (errorMessage.includes('TF400813') || e.status === 401) {
              console.error('Azure DevOps session expired. User needs to refresh the page.', e);
              throw new SessionExpiredError(
                'Your Azure DevOps session has expired. Please refresh the page and try again.',
              );
            }
            // For other errors, retry once
            console.warn('SDK.getAppToken failed. Retrying in 2s...', e);
            await new Promise((r) => setTimeout(r, 2000));
            return await SDK.getAppToken();
          }
        };

        function parseJwt(token) {
          try {
            return JSON.parse(atob(token.split('.')[1]));
          } catch (e) {
            return null;
          }
        }

        async function initialize() {
          // Determine theme (simple check)
          const theme = SDK.getConfiguration().colorTheme;
          if (theme && theme.kind === 2) {
            // Dark
            document.body.classList.add('dark-mode');
          }

          document.getElementById('createItemsBtn').addEventListener('click', onCreateItems);
          document.getElementById('discardBtn').addEventListener('click', onDiscard);
          document.getElementById('addItemBtn').addEventListener('click', onAddItem);

          // Chat listeners
          document.getElementById('sendChatBtn').addEventListener('click', onSendChatMessage);
          document.getElementById('clearChatBtn').addEventListener('click', onClearChat);
          document.getElementById('chatInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              onSendChatMessage();
            }
          });

          // Start polling for data sharing
          startPollingForSharedData();
        }

        async function startPollingForSharedData() {
          try {
            const workItemFormService = await SDK.getService('ms.vss-work-web.work-item-form');
            const workItemId = await workItemFormService.getId();

            const resultKey = `taskGenie_results_${workItemId}`;
            const executionKey = `taskGenie_execution_${workItemId}`;

            console.log('Checking for saved data:', resultKey, executionKey);

            // Poll check function
            const checkData = async () => {
              try {
                // Check for new execution request first
                const executionRaw = localStorage.getItem(executionKey);
                if (executionRaw && executionRaw !== lastRawData && !isPollingBackend) {
                  lastRawData = executionRaw;
                  const executionData = JSON.parse(executionRaw);

                  // Check if this is a fresh request (compare timestamp?)
                  // For now, if we see it and it changed, we process it.
                  if (executionData && executionData.executionId) {
                    console.log('Found execution details:', executionData.executionId);
                    handleExecutionRequest(executionData);
                    return;
                  }
                }

                // Check for results
                const resultRaw = localStorage.getItem(resultKey);
                if (resultRaw && resultRaw !== lastRawData && !isPollingBackend) {
                  // Only load if different and not currently polling something else
                  lastRawData = resultRaw;
                  const data = JSON.parse(resultRaw);
                  if (data && data.workItems) {
                    generatedItems = data.workItems;
                    sourceWorkItem = data.workItem;
                    currentConfig = data.config;

                    // Ensure IDs
                    generatedItems = generatedItems.map((item) => ({
                      ...item,
                      _tempId: item._tempId || Date.now() + Math.random().toString(36).substr(2, 9),
                      _isEditing: false,
                    }));

                    renderResults();
                  }
                }
              } catch (e) {
                console.error('Error checking for saved data', e);
              }
            };

            // Initial check
            checkData();

            // Set interval
            pollInterval = setInterval(checkData, 2000);

            // Add listener for storage events
            window.addEventListener('storage', (event) => {
              if (event.key === resultKey || event.key === executionKey) {
                checkData();
              }
            });
          } catch (e) {
            console.error('Error initializing polling', e);
            showStatus('Error initializing tab: ' + e.message, 'error');
          }
        }

        async function handleExecutionRequest(executionData) {
          isPollingBackend = true;
          showLoadingState();

          // Clear previous results
          generatedItems = [];
          // Do NOT call renderResults() here as it triggers showEmptyState() which hides the loader

          try {
            const { executionId, config, sourceWorkItem: srcItem } = executionData;
            sourceWorkItem = srcItem;
            currentConfig = config;

            const result = await pollForCompletion(config.apiUrl, executionId);

            if (result && result.result && result.result.workItems) {
              generatedItems = result.result.workItems;
              // Add temp IDs
              generatedItems = generatedItems.map((item) => ({
                ...item,
                _tempId: item._tempId || Date.now() + Math.random().toString(36).substr(2, 9),
                _isEditing: false,
              }));

              renderResults();

              // Save results to local storage so they persist on reload/swapping tabs
              try {
                const workItemFormService = await SDK.getService('ms.vss-work-web.work-item-form');
                const workItemId = await workItemFormService.getId();
                const resultKey = `taskGenie_results_${workItemId}`;
                const executionKey = `taskGenie_execution_${workItemId}`;
                const payload = {
                  workItems: generatedItems,
                  workItem: sourceWorkItem,
                  config: currentConfig,
                  timestamp: Date.now(),
                };
                localStorage.setItem(resultKey, JSON.stringify(payload));
                lastRawData = JSON.stringify(payload);

                // Clear the trigger key so we don't re-poll on reload
                localStorage.removeItem(executionKey);
              } catch (e) {
                console.error('Error saving results to storage', e);
              }
            } else {
              throw new Error('No work items returned.');
            }
          } catch (e) {
            console.error('Could not find execution results', e);
            if (e.name === 'SessionExpiredError') {
              showStatus(e.message, 'error');
            } else {
              showStatus('Generation failed: ' + e.message, 'error');
            }
            showEmptyState();
          } finally {
            isPollingBackend = false;
            document.getElementById('loadingState').classList.add('hidden');
          }
        }

        async function pollForCompletion(apiUrl, executionId) {
          const pollUrl = `${apiUrl}/${executionId}`;
          const maxAttempts = 60; // 300 seconds timeout
          const delay = 5000;

          for (let i = 0; i < maxAttempts; i++) {
            // Wait first
            await new Promise((resolve) => setTimeout(resolve, delay));

            try {
              // Get App Token
              const token = await getAppToken();

              console.log(`Polling for execution results at ${pollUrl}`);

              const resp = await fetch(pollUrl, {
                headers: { Authorization: `Bearer ${token}` },
              });

              if (resp.status === 200) {
                const data = await resp.json();
                const status = (data.status || '').toLowerCase();

                if (status === 'completed' || status === 'succeeded') {
                  console.log('Execution completed:', data);
                  return data;
                } else if (status === 'failed') {
                  throw new Error('Task Genie execution failed');
                }
              }
            } catch (e) {
              console.error('Could not poll for execution results', e);
            }
          }
          throw new Error('Polling timed out');
        }

        function renderResults() {
          const container = document.getElementById('itemsContainer');
          container.innerHTML = '';

          if (!generatedItems || generatedItems.length === 0) {
            showEmptyState();
            return;
          }

          document.getElementById('emptyState').classList.add('hidden');
          document.getElementById('resultsArea').classList.remove('hidden');

          generatedItems.forEach((item, index) => {
            const card = document.createElement('div');
            card.className = 'work-item-card';
            card.dataset.id = item._tempId;

            if (item._isEditing) {
              // Edit Mode
              card.innerHTML = `
                    <div class="edit-mode">
                        <label style="display:block;margin-bottom:4px;font-size:11px;font-weight:600;">Type</label>
                        <input type="text" class="edit-input item-type" value="${escapeHtml(item.workItemType)}" placeholder="e.g. Task, User Story" />

                        <label style="display:block;margin-bottom:4px;font-size:11px;font-weight:600;">Title</label>
                        <input type="text" class="edit-input item-title" value="${escapeHtml(item.title)}" placeholder="Title" />

                        <label style="display:block;margin-bottom:4px;font-size:11px;font-weight:600;">Description</label>
                        <textarea class="edit-textarea item-desc" placeholder="Description">${escapeHtml(item.description)}</textarea>

                        <div class="edit-controls">
                            <button class="btn-secondary btn-sm cancel-btn">Cancel</button>
                            <button class="btn-primary btn-sm save-btn">Save</button>
                        </div>
                    </div>
                `;

              // Bind events
              const cancelBtn = card.querySelector('.cancel-btn');
              const saveBtn = card.querySelector('.save-btn');

              cancelBtn.onclick = () => {
                if (item._isNew && !item.title) {
                  onDeleteItem(index);
                } else {
                  item._isEditing = false;
                  item._isNew = false;
                  renderResults();
                }
              };

              saveBtn.onclick = () => {
                const newType = card.querySelector('.item-type').value;
                const newTitle = card.querySelector('.item-title').value;
                const newDesc = card.querySelector('.item-desc').value;

                if (!newTitle) {
                  alert('Title is required');
                  return;
                }

                item.workItemType = newType;
                item.title = newTitle;
                item.description = newDesc;
                item._isEditing = false;
                item._isNew = false;

                renderResults();
              };
            } else {
              // View Mode
              card.innerHTML = `
                    <div class="card-header">
                        <span class="work-item-type">${escapeHtml(item.workItemType)}</span>
                        <span class="work-item-title">${escapeHtml(item.title)}</span>
                        <div class="card-actions">
                            <button class="btn-icon edit-btn" title="Edit">
                                <svg fill="currentColor" height="14" viewBox="0 0 16 16" width="14"><path d="M11.06 1.31L13.69 3.94 4.5 13.13 1.88 10.5 11.06 1.31ZM10 2.38L2.94 9.44 4.56 11.06 11.63 4 10 2.38ZM1.06 11.31L4.69 14.94 0 16 1.06 11.31ZM2.13 12.38L1.5 14.5 3.63 13.88 2.13 12.38Z"/></svg>
                            </button>
                            <button class="btn-icon delete-btn" title="Delete">
                                <svg fill="currentColor" height="14" viewBox="0 0 16 16" width="14"><path d="M14 3H9.1L8.6 2.3H5.4L4.9 3H0V4H14V3ZM2 5H12V14.5C12 14.8 11.8 15 11.5 15H2.5C2.2 15 2 14.8 2 14.5V5ZM3 14H11V5H3V14Z"/></svg>
                            </button>
                        </div>
                    </div>
                    <div class="work-item-description">${item.description}</div>
                `;

              card.querySelector('.edit-btn').onclick = () => {
                generatedItems.forEach((i) => (i._isEditing = false)); // Close others
                item._isEditing = true;
                renderResults();
              };

              card.querySelector('.delete-btn').onclick = () => onDeleteItem(index);
            }

            container.appendChild(card);
          });
        }

        function onAddItem() {
          const newItem = {
            workItemType: 'Task',
            title: '',
            description: '',
            _isEditing: true,
            _isNew: true,
            _tempId: Date.now() + Math.random().toString(36).substr(2, 9),
          };
          generatedItems.push(newItem);
          // Switch off other edits
          generatedItems.forEach((i) => {
            if (i !== newItem) i._isEditing = false;
          });

          document.getElementById('emptyState').classList.add('hidden');
          document.getElementById('resultsArea').classList.remove('hidden');

          renderResults();

          // Scroll to bottom
          const container = document.getElementById('itemsContainer');
          container.lastElementChild.scrollIntoView({ behavior: 'smooth' });
        }

        function onDeleteItem(index) {
          if (confirm('Are you sure you want to delete this item?')) {
            generatedItems.splice(index, 1);
            renderResults();
          }
        }

        function escapeHtml(text) {
          if (!text) return '';
          return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
        }

        function showEmptyState() {
          document.getElementById('resultsArea').classList.add('hidden');
          document.getElementById('loadingState').classList.add('hidden');
          document.getElementById('emptyState').classList.remove('hidden');
        }

        function showLoadingState() {
          document.getElementById('resultsArea').classList.add('hidden');
          document.getElementById('emptyState').classList.add('hidden');
          document.getElementById('loadingState').classList.remove('hidden');
        }

        async function onCreateItems() {
          const btn = document.getElementById('createItemsBtn');
          btn.disabled = true;
          showStatus('Creating items...', 'info', true);

          try {
            if (!currentConfig || !currentConfig.apiUrl) {
              throw new Error('Configuration missing (ApiUrl). Please try generating again.');
            }

            if (generatedItems.length === 0) {
              alert('No items to create.');
              btn.disabled = false;
              showStatus('', 'hidden');
              return;
            }

            // Remove internal state properties
            const cleanedItems = generatedItems.map((item) => {
              const { _tempId, _isEditing, _isNew, ...rest } = item;
              return rest;
            });

            const requestBody = {
              resource: sourceWorkItem.resource,
              generatedWorkItems: cleanedItems,
              params: {
                preview: false,
              },
            };

            console.log('Request body:', requestBody);

            // Get fresh token for creation
            const token = await getAppToken();

            const response = await fetch(currentConfig.apiUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${token}`,
              },
              body: JSON.stringify(requestBody),
            });

            if (!response.ok) throw new Error('Failed to submit creation');

            showStatus('Creation process started successfully!', 'success');

            // Clear data
            await clearSharedData();

            // Wait a bit then clear UI
            setTimeout(() => {
              generatedItems = [];
              renderResults();
              showStatus('', 'hidden');
              btn.disabled = false;
            }, 2000);
          } catch (e) {
            console.error(e);
            if (e.name === 'SessionExpiredError') {
              showStatus(e.message, 'error');
            } else {
              showStatus('Error creating items: ' + e.message, 'error');
            }
            btn.disabled = false;
          }
        }

        async function onDiscard() {
          await clearSharedData();
          generatedItems = [];
          renderResults();
          showStatus('Discarded.', 'info');
          setTimeout(() => showStatus('', 'hidden'), 1500);
        }

        async function clearSharedData() {
          try {
            const workItemFormService = await SDK.getService('ms.vss-work-web.work-item-form');
            const workItemId = await workItemFormService.getId();

            const resultKey = `taskGenie_results_${workItemId}`;
            const executionKey = `taskGenie_execution_${workItemId}`;
            localStorage.removeItem(resultKey);
            localStorage.removeItem(executionKey);
          } catch (e) {
            console.error('Error clearing shared data', e);
          }
        }

        function showStatus(msg, type, spinner = false) {
          const el = document.getElementById('statusContainer');
          if (type === 'hidden') {
            el.classList.add('hidden');
            return;
          }

          let content = msg;
          if (spinner) {
            content = `<div class="spinner"></div> ${msg}`;
          }

          el.className = `status-message status-${type}`;
          el.innerHTML = content;
          el.classList.remove('hidden');
        }

        // --- Chat Functions ---

        async function onSendChatMessage() {
          const inputEl = document.getElementById('chatInput');
          const message = inputEl.value.trim();

          if (!message) return;

          // Add user message
          addMessage(message, 'user');
          inputEl.value = '';

          // Show typing indicator
          const typingIndicator = document.getElementById('typingIndicator');
          typingIndicator.style.display = 'block';

          // Scroll to bottom
          const messagesContainer = document.getElementById('chatMessages');
          messagesContainer.scrollTop = messagesContainer.scrollHeight;

          // Mock AI response
          try {
            // Simulate network delay
            await new Promise((resolve) => setTimeout(resolve, 1500));

            // Hide typing indicator
            typingIndicator.style.display = 'none';

            // Mock logic for response
            let response = 'This chat feature is not yet implemented but will be available in a future release.';

            addMessage(response, 'assistant');
          } catch (e) {
            typingIndicator.style.display = 'none';
            addMessage('Sorry, I encountered an error processing your request.', 'assistant');
            console.error(e);
          }
        }

        function addMessage(text, sender) {
          const messagesContainer = document.getElementById('chatMessages');
          const msgDiv = document.createElement('div');
          msgDiv.className = `message ${sender}`;
          msgDiv.textContent = text;
          messagesContainer.appendChild(msgDiv);
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function onClearChat() {
          const messagesContainer = document.getElementById('chatMessages');
          messagesContainer.innerHTML = `
                <div class="message assistant">
                  Hello! I can help you refine these work items. Tell me what changes you'd like to make.
                </div>
            `;
        }
      });
    </script>
  </body>
</html>
