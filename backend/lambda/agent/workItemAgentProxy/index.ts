import { BedrockAgentCoreClient, InvokeAgentRuntimeCommand } from '@aws-sdk/client-bedrock-agentcore'; // ES Modules import
import { NodeHttpHandler } from '@smithy/node-http-handler';
import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { Logger } from '@aws-lambda-powertools/logger';
import {
  WorkItemRequest,
  WorkItemImage,
  WorkItem,
  ProductBacklogItem,
  UserStory,
  Epic,
  Feature,
  isProductBacklogItem,
  isUserStory,
  isEpic,
  isFeature,
} from '../../../types/azureDevOps';
import { WorkItemGenerationMode } from '../../../types/bedrock';
import { InvalidWorkItemError } from '../../../types/errors';
import { injectLambdaContext } from '@aws-lambda-powertools/logger/middleware';
import { v4 as uuid } from 'uuid';
import middy from '@middy/core';

const logger = new Logger({ serviceName: 'workItemAgentProxy' });

const agentRuntimeArn = process.env.BEDROCK_AGENTCORE_RUNTIME_ARN;
if (!agentRuntimeArn) {
  throw new Error('Server configuration error: Missing BEDROCK_AGENTCORE_RUNTIME_ARN');
}

// CORS headers for cross-origin requests
const CORS_HEADERS = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'Content-Type,x-api-key,Authorization',
  'Access-Control-Allow-Methods': 'POST,OPTIONS',
};

export const lambdaHandler = async (event: APIGatewayProxyEvent, context: Context): Promise<APIGatewayProxyResult> => {
  // Handle preflight OPTIONS request
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: CORS_HEADERS,
      body: '',
    };
  }

  try {
    const client = new BedrockAgentCoreClient({
      maxAttempts: 1, // Disable retries to prevent duplicate executions on timeout
      requestHandler: new NodeHttpHandler({
        socketTimeout: 300000, // 5 minutes - explicit socket timeout
        connectionTimeout: 5000, // 5 seconds connection timeout
      }),
    });

    // Handle different API Gateway integration modes:
    // - Proxy integration (proxy: true): body is in event.body as a string
    // - Non-proxy async integration (proxy: false): event IS the body directly (already parsed)
    let requestBody: any;
    if (event.body !== undefined) {
      // Proxy integration - parse body string
      requestBody = typeof event.body === 'string' ? JSON.parse(event.body) : event.body;
    } else if ((event as any).resource && (event as any).params) {
      // Non-proxy integration - event IS the body
      requestBody = event;
    } else {
      throw new Error('Unable to parse request body from event');
    }

    // Validate required fields in the work item
    validateWorkItem(requestBody.resource);
    logger.info('Validated request body resource', { resource: requestBody.resource });

    // Parse and sanitize fields
    const { workItem, params } = parseEvent(requestBody);

    // Validate parameters
    validateParams(params);

    // Use sessionId from request (generated by client for async invocation)
    const sessionId = requestBody.sessionId || `ado-${workItem.workItemId}-rev-${workItem.rev}-${uuid()}`;

    const input = {
      runtimeSessionId: sessionId,
      agentRuntimeArn,
      qualifier: 'DEFAULT',
      contentType: 'application/json',
      accept: 'text/event-stream',
      //payload: new TextEncoder().encode(JSON.stringify({ workItem, params })),
      // Include sessionId in payload so agent can use it as executionId for DynamoDB
      payload: Buffer.from(JSON.stringify({ body: { workItem, params, sessionId } })),
    };

    logger.info('âš™ï¸ Invoking Bedrock Agent Runtime', {
      agentRuntimeArn,
      qualifier: input.qualifier,
      runtimeSessionId: input.runtimeSessionId,
      workItem,
      params,
    });

    const command = new InvokeAgentRuntimeCommand(input);

    // With async Lambda invocation (Event type), Lambda runs to completion in background
    // API Gateway returns 202 immediately, but Lambda continues executing
    // The agent will save results to DynamoDB with the sessionId as executionId
    try {
      const response = await client.send(command);
      const textResponse = await response.response?.transformToString();
      logger.info('âœ… Bedrock Agent Runtime completed', { sessionId, textResponse });
    } catch (agentError) {
      logger.error('ðŸ›‘ Bedrock Agent Runtime failed', { sessionId, error: String(agentError) });
    }

    // This response is not returned to client (async invocation)
    // but we return 200 to indicate successful Lambda execution
    return {
      statusCode: 200,
      headers: CORS_HEADERS,
      body: JSON.stringify({
        message: 'Work item processing completed',
        sessionId: sessionId,
      }),
    };
  } catch (error) {
    if (error instanceof InvalidWorkItemError) {
      logger.error(`ðŸ›‘ Validation error: ${error.message}`, { details: error, statusCode: error.code });
      return {
        statusCode: error.code,
        headers: CORS_HEADERS,
        body: JSON.stringify({ error: error.message, details: error }),
      };
    }

    logger.error(`ðŸ›‘ Error invoking agent runtime: ${error}`);
    return {
      statusCode: 500,
      headers: CORS_HEADERS,
      body: JSON.stringify({ error: 'ðŸ›‘ Internal Server Error' }),
    };
  }
};

const validateWorkItem = (resource: any) => {
  const commonRequiredFields = [
    'System.TeamProject',
    'System.AreaPath',
    'System.IterationPath',
    'System.ChangedBy',
    'System.Title',
    'System.Description',
    'System.WorkItemType',
  ];

  if (!resource) {
    throw new InvalidWorkItemError('Bad request', 'Work item resource is undefined or missing.', 400);
  }

  // Handle different payload structures for created vs updated work items
  // For updates: fields are in resource.revision.fields
  // For creates: fields are directly in resource.fields
  const fields = resource.revision?.fields || resource.fields;
  if (!fields) {
    throw new InvalidWorkItemError('Bad request', 'Work item fields are undefined or missing.', 400);
  }

  // Validate common required fields
  for (const field of commonRequiredFields) {
    if (!fields[field]) {
      logger.error('Work item is missing a required field', { field: field });
      throw new InvalidWorkItemError('Bad request', `Work item is missing required field: ${field}.`, 400);
    }
  }

  // Validate work item type is supported
  const workItemType = fields['System.WorkItemType'];
  const supportedTypes = ['Product Backlog Item', 'User Story', 'Epic', 'Feature'];
  if (!supportedTypes.includes(workItemType)) {
    throw new InvalidWorkItemError(
      'Unsupported work item type',
      `Work item type '${workItemType}' is not supported. Supported types: ${supportedTypes.join(', ')}.`,
      400,
    );
  }

  // Type-specific validation
  if (isProductBacklogItem(workItemType)) {
    // Product Backlog Item should have acceptance criteria (but make it optional to be lenient)
    if (!fields['Microsoft.VSTS.Common.AcceptanceCriteria']) {
      logger.warn('Product Backlog Item is missing acceptance criteria', {
        workItemId: resource.workItemId || resource.id,
      });
    }
  }
  if (isUserStory(workItemType)) {
    // User Story should have acceptance criteria (but make it optional to be lenient)
    if (!fields['Microsoft.VSTS.Common.AcceptanceCriteria']) {
      logger.warn('User Story is missing acceptance criteria', {
        workItemId: resource.workItemId || resource.id,
      });
    }
  }
  if (isEpic(workItemType) || isFeature(workItemType)) {
    // Epic and Feature should have success criteria (but make it optional to be lenient)
    if (!fields['Custom.SuccessCriteria']) {
      logger.warn(`${workItemType} is missing success criteria`, {
        workItemId: resource.workItemId || resource.id,
      });
    }
  }
};

/**
 * Extracts image URLs and alt text from HTML and Markdown content
 * @param htmlContent The HTML content to parse
 * @param context The context in which the HTML content is used (e.g., 'Description', 'AcceptanceCriteria')
 * @returns Array of WorkItemImage objects with URLs and alt text found in the content
 */
const extractImageUrls = (htmlContent: string, context: string): WorkItemImage[] => {
  if (!htmlContent || typeof htmlContent !== 'string') {
    return [];
  }

  const images: WorkItemImage[] = [];

  // Extract images from HTML tags: <img>
  const imgRegex = /<img[^>]*>/gi;
  let htmlMatch;

  while ((htmlMatch = imgRegex.exec(htmlContent)) !== null) {
    const imgTag = htmlMatch[0];

    // Extract src attribute
    const srcMatch = imgTag.match(/\ssrc\s*=\s*["']?([^"'\s>]+)["']?/i);
    // Extract alt attribute
    const altMatch = imgTag.match(/\salt\s*=\s*["']?([^"'>]*)["']?/i);

    if (srcMatch && srcMatch[1] && srcMatch[1].trim()) {
      images.push({
        url: srcMatch[1].trim(),
        alt: altMatch && altMatch[1] && altMatch[1].trim() ? altMatch[1].trim() : undefined,
      });
    }
  }

  // Extract images from Markdown image syntax: ![alt](url)
  const markdownImgRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
  let markdownMatch;

  while ((markdownMatch = markdownImgRegex.exec(htmlContent)) !== null) {
    const alt = markdownMatch[1].trim();
    const url = markdownMatch[2].trim();

    if (url) {
      images.push({
        url: url,
        alt: alt || undefined,
      });
    }
  }

  return images;
};

const parseEvent = (requestBody: any): WorkItemRequest => {
  const { params, resource } = requestBody;
  const workItemId = resource.workItemId || resource.id;
  const rev = resource.rev;
  const fields = resource.revision?.fields || resource.fields;
  const workItemType = fields['System.WorkItemType'] as 'Product Backlog Item' | 'User Story' | 'Epic' | 'Feature';

  const tagsString = sanitizeField(fields['System.Tags'] ?? '');
  const tags = tagsString ? tagsString.split(';').map((tag: string) => tag.trim()) : [];

  // Extract raw HTML content before sanitization for type-specific fields
  const rawDescription = fields['System.Description'] || '';

  // Get type-specific criteria field content
  let rawCriteriaContent = '';
  const allImages: WorkItemImage[] = [];

  if (workItemType === 'Product Backlog Item' || workItemType === 'User Story') {
    rawCriteriaContent = fields['Microsoft.VSTS.Common.AcceptanceCriteria'] || '';
  } else if (workItemType === 'Epic' || workItemType === 'Feature') {
    rawCriteriaContent = fields['Custom.SuccessCriteria'] || '';
  }

  // Extract image URLs from description and criteria content
  const descriptionImages = extractImageUrls(rawDescription, 'Description');
  const criteriaImages = extractImageUrls(
    rawCriteriaContent,
    workItemType === 'Product Backlog Item' || workItemType === 'User Story' ? 'AcceptanceCriteria' : 'SuccessCriteria',
  );
  allImages.push(...descriptionImages, ...criteriaImages);

  // Remove duplicates based on URL
  const uniqueImages = allImages.filter(
    (image, index, self) => index === self.findIndex((img) => img.url === image.url),
  );

  // Create base work item with common fields
  const changedByValue = sanitizeField(fields['System.ChangedBy']).replace(/<.*?>/, '').trim();
  const baseWorkItem = {
    workItemId: workItemId ?? 0,
    rev: rev ?? 0,
    workItemType,
    teamProject: sanitizeField(fields['System.TeamProject']),
    areaPath: sanitizeField(fields['System.AreaPath']),
    iterationPath: sanitizeField(fields['System.IterationPath']),
    amaValueArea: fields['Custom.AMAValueArea'] ? sanitizeField(fields['Custom.AMAValueArea']) : undefined, // Custom Field
    businessUnit: fields['Custom.BusinessUnit'] ? sanitizeField(fields['Custom.BusinessUnit']) : undefined, // Custom Field
    system: fields['Custom.System'] ? sanitizeField(fields['Custom.System']) : undefined, // Custom Field
    releaseNotes: fields['Custom.ReleaseNotes'] ? sanitizeField(fields['Custom.ReleaseNotes']) : undefined, // Custom Field
    qaNotes: fields['Custom.QANotes'] ? sanitizeField(fields['Custom.QANotes']) : undefined, // Custom Field
    changedBy: changedByValue,
    originalChangedBy: changedByValue, // Preserve the original submitter for @mentions in comments
    title: sanitizeField(fields['System.Title']),
    description: sanitizeField(rawDescription),
    tags,
    images: uniqueImages.length > 0 ? uniqueImages : undefined,
  };

  // Create type-specific work item
  let workItem: WorkItem;
  if (workItemType === 'Product Backlog Item') {
    workItem = {
      ...baseWorkItem,
      workItemType: 'Product Backlog Item',
      acceptanceCriteria: sanitizeField(rawCriteriaContent),
      importance: fields['Custom.Importance'] ? sanitizeField(fields['Custom.Importance']) : undefined,
    } as ProductBacklogItem;
  } else if (workItemType === 'User Story') {
    workItem = {
      ...baseWorkItem,
      workItemType: 'User Story',
      acceptanceCriteria: sanitizeField(rawCriteriaContent),
      importance: fields['Custom.Importance'] ? sanitizeField(fields['Custom.Importance']) : undefined,
    } as UserStory;
  } else if (workItemType === 'Epic') {
    workItem = {
      ...baseWorkItem,
      workItemType: 'Epic',
      successCriteria: sanitizeField(rawCriteriaContent),
      objective: fields['Custom.Objective'] ? sanitizeField(fields['Custom.Objective']) : undefined,
      addressedRisks: fields['Custom.AddressedRisks'] ? sanitizeField(fields['Custom.AddressedRisks']) : undefined,
      pursueRisk: fields['Custom.PursueRisk'] ? sanitizeField(fields['Custom.PursueRisk']) : undefined,
      mostRecentUpdate: fields['Custom.MostRecentUpdate']
        ? sanitizeField(fields['Custom.MostRecentUpdate'])
        : undefined,
      outstandingActionItems: fields['Custom.OutstandingActionItems']
        ? sanitizeField(fields['Custom.OutstandingActionItems'])
        : undefined,
    } as Epic;
  } else if (workItemType === 'Feature') {
    workItem = {
      ...baseWorkItem,
      workItemType: 'Feature',
      successCriteria: sanitizeField(rawCriteriaContent),
      businessDeliverable: fields['Custom.BusinessDeliverable']
        ? sanitizeField(fields['Custom.BusinessDeliverable'])
        : undefined,
    } as Feature;
  } else {
    throw new Error(`Unsupported work item type: ${workItemType}`);
  }

  logger.info(`â–¶ï¸ Starting evaluation of ${workItem.workItemType} ${workItem.workItemId}-rev${workItem.rev}`, {
    workItemType: workItem.workItemType,
    title: workItem.title,
    areaPath: workItem.areaPath,
    amaValueArea: workItem.amaValueArea,
    businessUnit: workItem.businessUnit,
    system: workItem.system,
    releaseNotes: workItem.releaseNotes,
    qaNotes: workItem.qaNotes,
    iterationPath: workItem.iterationPath,
    hasImages: !!(workItem.images && workItem.images.length > 0),
    imagesCount: workItem.images?.length || 0,
  });

  return { params: params ?? {}, workItem };
};

const sanitizeField = (fieldValue: any, fieldName?: string): string => {
  if (typeof fieldValue !== 'string') {
    const fieldContext = fieldName ? ` for field '${fieldName}'` : '';
    throw new Error(`Invalid field value${fieldContext}: expected a string, got ${typeof fieldValue} (${fieldValue}).`);
  }
  return fieldValue.replace(/<[^>]*>/g, '').trim();
};

const validateParams = (params: any) => {
  if (!params) return;

  const { mode, generatedWorkItems } = params;

  if (mode) {
    const validModes = Object.values(WorkItemGenerationMode);
    if (!validModes.includes(mode as WorkItemGenerationMode)) {
      throw new InvalidWorkItemError(
        'Invalid mode',
        `Mode '${mode}' is not supported. Supported modes: ${validModes.join(', ')}.`,
        400,
      );
    }

    if (mode === WorkItemGenerationMode.Create && (!generatedWorkItems || generatedWorkItems.length === 0)) {
      throw new InvalidWorkItemError(
        'Missing generatedWorkItems',
        'Mode "create" requires "generatedWorkItems" to be present and non-empty.',
        400,
      );
    }
  }
};

export const handler = middy(lambdaHandler).use(injectLambdaContext(logger, { logEvent: true }));
